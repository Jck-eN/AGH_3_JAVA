<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>Laboratorium 2</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body>
        <h1 id="laboratorium-2">Laboratorium 2</h1>
<p>Celem laboratorium jest zapoznanie się z modelem obiektowym Javy.</p>
<h2 id="zadania-do-wykonania">Zadania do wykonania</h2>
<h3 id="klasa-vector2d">Klasa <code>Vector2d</code></h3>
<ol>
<li>Pliki projektu należy umieszczać w pakiecie <code>agh.cs.lab2</code>.</li>
<li>Utwórz klasę <code>CarSystem</code> z metodą <code>main</code>.</li>
<li>Utwórz klasę <code>Vector2d</code>, która:
<ul>
<li>posiada dwa publiczne pola <code>x</code> i <code>y</code> typu <code>int</code>, które nie mogą być modyfikowane (<code>final</code>),</li>
<li>posiada konstruktor akceptujący parametry <code>x</code> i <code>y</code>, która są przypisywane do pól <code>x</code> i <code>y</code>,</li>
<li>posiada metodę <code>toString</code>, która zamienia pozycję na napis <code>(x,y)</code>, np. dla <code>x = 1</code> oraz <code>y = 2</code>, napis ma postać
<code>(1,2)</code>,</li>
<li>posiada metodę <code>smaller</code>, akceptującą inny obiekt tej klasy i zwracającą wartość <code>true</code>, jeśli oba pola mają
wartość mniejszą bądź równą polom drugiego obiektu,</li>
<li>posiada metodę <code>larger</code>, akceptującą inny obiekt tej klasy i zwracającą wartość <code>true</code>, jeśli oba pola mają
wartość większą bądź równą polom drugiego obiektu,</li>
<li>posiada metodę <code>upperRight</code>, która akceptuje inny punkt i zwraca obiekt klasy <code>Vector2d</code> posiadający te składowe
punktów, które mają większe wartości dla odpowiednich osi (innymi słowy jest prawym górnym rogiem prostokąta, który
opisany jest na obu punktach),</li>
<li>posiada metodę <code>lowerLeft</code>, która akceptuje inny punkt i zwraca obiekt klasy <code>Vector2d</code> posiadający te składowe
punktów, które mają mniejsze wartości dla odpowiednich osi (tzn. lewy dolny róg prostokąta),</li>
<li>posiada metodę <code>add</code>, która zwraca nowy obiekt klasy <code>Vector2d</code>, którego składowe są sumą odpowiednich składowych
dodawanych pozycji,</li>
<li>posiada metodę <code>subtract</code>, która zwraca nowy obiekt klasy <code>Vector2d</code>, którego składowe są różnicą
odpowiednich składowych odejmowanych pozycji,</li>
<li>posiada metodę <code>boolean equals(Object other)</code> która zwraca prawdę jeśli obie pozycje są sobie równe.</li>
</ul>
</li>
<li>W metodzie <code>main</code> wprowadź następujący kod:</li>
</ol>
<pre><code class="language-java"><div>Vector2d position1 = <span class="hljs-keyword">new</span> Vector2d(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
System.out.println(position1);
Vector2d position2 = <span class="hljs-keyword">new</span> Vector2d(-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);
System.out.println(position2);
System.out.println(position1.add(position2));
</div></code></pre>
<p>Sprawdź czy uzyskane wyniki są poprawne.</p>
<h3 id="pozosta%c5%82e-klasy">Pozostałe klasy</h3>
<ol start="6">
<li>Utwórz typ wyliczeniowy <code>MoveDirection</code> z czterema kierunkami: <code>FORWARD, BACKWARD, RIGHT, LEFT</code>.</li>
<li>Utwórz typ wyliczeniowy <code>MapDirection</code> z czterema kierunkami: <code>NORTH, SOUTH, WEST, EAST</code>, który:
<ul>
<li>posiada metodę <code>toString</code>, która dla kierunku <code>EAST</code> zwraca łańcuch <code>Wschód</code>, dla <code>WEST</code> - <code>Zachód</code>, itd.</li>
<li>posiada metodę <code>next</code>, która dla kierunku <code>EAST</code> zwraca <code>SOUTH</code> (kolejny kierunek zgodnie z ruchem wskazówek
zegara), itd.</li>
<li>posiada metodę <code>previous</code>, która dla kierunku <code>EAST</code> zwraca <code>NORTH</code> (kolejny kierunek zgodnie z ruchem przeciwnym
do ruchu wskazówek zegara), itd.</li>
<li>posiada metodę <code>toUnitVector</code>, która zwraca jednostkowy wektor przemieszczenia typu <code>Vector2d</code> zgodny z orientacją na mapie,
tzn. dla <code>NORTH</code> wektor ten powinien mieć wartość <code>(0,1)</code>, dla <code>EAST</code> <code>(1,0)</code>, itd.</li>
</ul>
</li>
<li>Sprawdź w metodzie <code>main</code> czy metody te działają zgodnie z opisem.</li>
</ol>
<h3 id="testy">Testy</h3>
<ol>
<li>Przenieś kod źródłowy do katalogu <code>src/main</code>.</li>
<li>Utwórz katalog <code>src/test</code>.</li>
<li>Dodaj bibliotekę JUnit 4 lub 5:
<ul>
<li>File -&gt; Project structure -&gt; Modules -&gt; Dependencies -&gt; (kliknij + po prawej stronie) -&gt; library -&gt; From maven</li>
<li>w okienko wpisujemy junit:junit -&gt; search</li>
<li>wybieramy dostępną wersję JUnit (najnowszą ale bez SNAPSHOT)</li>
<li>zmieniamy Scope na test (w okienku Dependencies)</li>
</ul>
</li>
<li>Utwórz klasę <code>MapDirectionTest</code>.</li>
<li>Zaimplementuj test weryfikujący poprawność działania metody <code>next()</code>, dla wszystkich przypadków (dodaj anotację
<code>@Test</code> przed deklaracją metody).</li>
<li>Uruchom test korzystając z menu <code>Run as</code>.</li>
<li>Zaimplementuj test weryfikujący poprawność działania metody <code>previous()</code>, dla wszystkich przypadków.</li>
<li>Utwórz klasę <code>Vector2dTest</code>.</li>
<li>Dodaj testy weryfikujące poprawność metod: <code>equals(Object other)</code>, <code>toString()</code>, <code>smaller(Vector2d other)</code>, <code>larger(Vector2d other)</code>,
<code>upperRight(Vector2d other)</code>, <code>lowerLeft(Vector2d other)</code> oraz <code>add(Vector2d other)</code>.</li>
</ol>
<h2 id="przydatne-informacje">Przydatne informacje</h2>
<ul>
<li>Pola w obiekcie deklarowane są w ciele klasy, np.</li>
</ul>
<pre><code><div>class Vector2d {
  public int x;
  public int y;
}
</div></code></pre>
<ul>
<li>Konstruktor jest specjalną metodą w każdej klasie. Nazywa się tak samo jak klasa i nie zwraca wartości. Konstruktor
pozwala ustalić początkową wartość pól obiektu jeśli mają być przekazane przez użytkownika, np.</li>
</ul>
<pre><code class="language-java"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector2d</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector2d</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
    <span class="hljs-keyword">this</span>.x = x;
    <span class="hljs-keyword">this</span>.y = y;
  }
}
</div></code></pre>
<ul>
<li>Obiekty klasy tworzy się za pomocą wywołania <code>new</code>, np.</li>
</ul>
<pre><code class="language-java"><div>Vector2d position1 = <span class="hljs-keyword">new</span> Vector2d(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
</div></code></pre>
<ul>
<li>Słowo kluczowe <code>this</code> odnosi się do obiekt, na rzecz którego wywołano metodę.
Przykładowo w języku C moglibyśmy zdefiniować metodę <code>createPoint</code>:</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> {</span>
  <span class="hljs-keyword">int</span> x;
  <span class="hljs-keyword">int</span> y;
}

<span class="hljs-function">struct Point * <span class="hljs-title">createPoint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>{
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> * <span class="hljs-title">result</span> = <span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Point</span>));</span>
  result-&gt;x = x;
  result-&gt;y = y;
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> * <span class="hljs-title">p1</span> = <span class="hljs-title">createPoint</span>(1,2);</span>
</div></code></pre>
<p>Ten kod jest analogiczny do konstruktora, z ta różnicą, że w konstruktorze nie tworzymy obiektu <em>explicite</em>, tylko mamy do
niego dostęp za pomocą słowa kluczowego <code>this</code>.</p>
<ul>
<li>Metoda <code>equals</code> ma zwykle taki sam schemat:</li>
</ul>
<pre><code class="language-java"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object other)</span></span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == other)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  <span class="hljs-keyword">if</span> (!(other <span class="hljs-keyword">instanceof</span> Vector2d))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
  Vector2d that = (Vector2d) other;
  <span class="hljs-comment">// tutaj przeprowadzane jest faktyczne porównanie</span>
}
</div></code></pre>
<p>Należy również wiedzieć, że zmiana metody <code>equals</code> powinna powodować zmianę metody <code>hashCode</code>, w przeciwnym razie
umieszczenie obiektów w kolekcji takiej jak <code>Set</code> będzie niezgodne z semantyką metody <code>equals</code>.</p>
<ul>
<li>Definicję typu wyliczeniowego można rozszerzać dodając do niego metody. Wymaga to umieszczenia średnika po ostatniej
wartości typu, np.:</li>
</ul>
<pre><code class="language-java"><div><span class="hljs-keyword">enum</span> MapDirection {
  NORTH,
  SOUTH,
  EAST,
  WEST;

  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">this</span>) {
      <span class="hljs-keyword">case</span> NORTH: <span class="hljs-keyword">return</span> <span class="hljs-string">"Północ"</span>;
      <span class="hljs-keyword">case</span> SOUTH: <span class="hljs-keyword">return</span> <span class="hljs-string">"Południe"</span>;
      <span class="hljs-comment">//...</span>
    }
  }
}
</div></code></pre>
<ul>
<li>
<p>Metody testujące posiadają adnotację <code>@Test</code>.</p>
</li>
<li>
<p>W metodach testujących można użyć następujących asercji:</p>
<ul>
<li><code>assertEquals(a, b)</code> - weryfikuje czy obiekty <code>a</code> i <code>b</code> są sobie równe (korzystając z metody <code>equals</code>),</li>
<li><code>assertTrue(a)</code> - weryfikuje czy wartość logiczna <code>a</code> jest prawdą,</li>
<li><code>assertFalse(a)</code> - weryfikuje czy wartość logiczna <code>a</code> jest fałszem.</li>
</ul>
</li>
</ul>

    </body>
    </html>